import * as log from 'electron-log';
import * as yaml from 'js-yaml';
import { customTimestampType } from './yaml-custom-ts';
export class YAMLStorage {
    constructor(fs, opts = { debugLog: false }) {
        this.fs = fs;
        this.opts = opts;
    }
    debugLog(message, level = 'debug') {
        if (this.opts.debugLog) {
            log[level](message);
        }
    }
    async load(filePath) {
        this.debugLog(`SSE: YAMLStorage: Loading ${filePath}`);
        const data = await this.fs.readFile(filePath, { encoding: 'utf8' });
        return yaml.load(data, { schema: SCHEMA });
    }
    async loadIfExists(filePath) {
        let fileExists;
        let oldData;
        try {
            fileExists = (await this.fs.stat(filePath)).isFile() === true;
        }
        catch (e) {
            fileExists = false;
        }
        if (fileExists) {
            oldData = await this.load(filePath);
        }
        else {
            oldData = {};
        }
        return oldData || {};
    }
    async store(filePath, data) {
        this.debugLog(`SSE: YAMLStorage: Storing ${filePath}`);
        this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: ${JSON.stringify(data)}`, 'silly');
        if (data !== undefined && data !== null) {
            // Merge new data into old data; this way if some YAML properties
            // are not supported we will not lose them after the update.
            let newData;
            let oldData;
            let newContents;
            try {
                oldData = await this.loadIfExists(filePath);
                this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Already existing data: ${oldData}`, 'silly');
                newData = Object.assign(oldData, data);
                this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Combined data to write: ${newData}`, 'silly');
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to store ${filePath}`);
                console.error("Bad input", filePath, oldData, data);
                throw e;
            }
            // console.debug(`Dumping contents for ${filePath} from ${data}`);
            // console.debug(oldData);
            try {
                newContents = yaml.dump(newData, {
                    schema: SCHEMA,
                    noRefs: true,
                    noCompatMode: true,
                });
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to dump ${filePath}: ${JSON.stringify(data)}`);
                console.error(`Failed to save ${filePath} with ${JSON.stringify(newData)}`, e);
                return;
            }
            // console.debug(`Writing to ${filePath}, file exists: ${fileExists}`);
            // if (fileExists) {
            //   const oldContents: string = await this.fs.readFile(filePath, { encoding: 'utf8' });
            //   console.debug(`Replacing contents of ${filePath}`, oldContents, newContents);
            // }
            this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Writing file`);
            this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Writing file: ${newContents}`, 'silly');
            await this.fs.writeFile(filePath, newContents, { encoding: 'utf8' });
            return data;
        }
        else {
            log.info(`SSE: YAMLStorage: Storing ${filePath}: Empty data given, removing file`);
            await this.fs.remove(filePath);
        }
    }
}
const SCHEMA = new yaml.Schema({
    include: [yaml.DEFAULT_SAFE_SCHEMA],
    // Trick because js-yaml API appears to not support augmenting implicit tags
    implicit: [
        ...yaml.DEFAULT_SAFE_SCHEMA.implicit,
        ...[customTimestampType],
    ],
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFtbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yYWdlL21haW4veWFtbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssR0FBRyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEtBQUssSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQVF2RCxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUFvQixFQUFPLEVBQVUsT0FBMkIsRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFO1FBQS9ELE9BQUUsR0FBRixFQUFFLENBQUs7UUFBVSxTQUFJLEdBQUosSUFBSSxDQUEwQztJQUFJLENBQUM7SUFFaEYsUUFBUSxDQUFDLE9BQWUsRUFBRSxRQUEyQixPQUFPO1FBQ2xFLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDdEIsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztJQUVNLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBZ0I7UUFDaEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyw2QkFBNkIsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUN2RCxNQUFNLElBQUksR0FBVyxNQUFNLElBQUksQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO1FBQzVFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU8sS0FBSyxDQUFDLFlBQVksQ0FBQyxRQUFnQjtRQUN6QyxJQUFJLFVBQW1CLENBQUM7UUFDeEIsSUFBSSxPQUFZLENBQUM7UUFFakIsSUFBSTtZQUNGLFVBQVUsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFD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SSxDQUFDLDZCQUE2QixRQUFRLG1DQUFtQyxDQUFDLENBQUM7WUFDbkYsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNoQztJQUNILENBQUM7Q0FDRjtBQUdELE1BQU0sTUFBTSxHQUFHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUM3QixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUM7SUFFbkMsNEVBQTRFO0lBQzVFLFFBQVEsRUFBRTtRQUNSLEdBQUksSUFBSSxDQUFDLG1CQUEyQixDQUFDLFFBQVE7UUFDN0MsR0FBRyxDQUFDLG1CQUFtQixDQUFDO0tBQ3pCO0NBQ0YsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbG9nIGZyb20gJ2VsZWN0cm9uLWxvZyc7XG5pbXBvcnQgKiBhcyB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgY3VzdG9tVGltZXN0YW1wVHlwZSB9IGZyb20gJy4veWFtbC1jdXN0b20tdHMnO1xuXG5cbmludGVyZmFjZSBZQU1MU3RvcmFnZU9wdGlvbnMge1xuICBkZWJ1Z0xvZzogYm9vbGVhbjtcbn1cblxuXG5leHBvcnQgY2xhc3MgWUFNTFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZzOiBhbnksIHByaXZhdGUgb3B0czogWUFNTFN0b3JhZ2VPcHRpb25zID0geyBkZWJ1Z0xvZzogZmFsc2UgfSkgeyB9XG5cbiAgcHJpdmF0ZSBkZWJ1Z0xvZyhtZXNzYWdlOiBzdHJpbmcsIGxldmVsOiAnc2lsbHknIHwgJ2RlYnVnJyA9ICdkZWJ1ZycpIHtcbiAgICBpZiAodGhpcy5vcHRzLmRlYnVnTG9nKSB7XG4gICAgICBsb2dbbGV2ZWxdKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IExvYWRpbmcgJHtmaWxlUGF0aH1gKTtcbiAgICBjb25zdCBkYXRhOiBzdHJpbmcgPSBhd2FpdCB0aGlzLmZzLnJlYWRGaWxlKGZpbGVQYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgcmV0dXJuIHlhbWwubG9hZChkYXRhLCB7IHNjaGVtYTogU0NIRU1BIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBsb2FkSWZFeGlzdHMoZmlsZVBhdGg6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgbGV0IGZpbGVFeGlzdHM6IGJvb2xlYW47XG4gICAgbGV0IG9sZERhdGE6IGFueTtcblxuICAgIHRyeSB7XG4gICAgICBmaWxlRXhpc3RzID0gKGF3YWl0IHRoaXMuZnMuc3RhdChmaWxlUGF0aCkpLmlzRmlsZSgpID09PSB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGZpbGVFeGlzdHMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlsZUV4aXN0cykge1xuICAgICAgb2xkRGF0YSA9IGF3YWl0IHRoaXMubG9hZChmaWxlUGF0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9sZERhdGEgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2xkRGF0YSB8fCB7fTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdG9yZShmaWxlUGF0aDogc3RyaW5nLCBkYXRhOiBhbnkpOiBQcm9taXNlPGFueT4ge1xuICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH1gKVxuICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCwgJ3NpbGx5Jyk7XG5cbiAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGEgIT09IG51bGwpIHtcbiAgICAgIC8vIE1lcmdlIG5ldyBkYXRhIGludG8gb2xkIGRhdGE7IHRoaXMgd2F5IGlmIHNvbWUgWUFNTCBwcm9wZXJ0aWVzXG4gICAgICAvLyBhcmUgbm90IHN1cHBvcnRlZCB3ZSB3aWxsIG5vdCBsb3NlIHRoZW0gYWZ0ZXIgdGhlIHVwZGF0ZS5cbiAgICAgIGxldCBuZXdEYXRhOiBhbnk7XG4gICAgICBsZXQgb2xkRGF0YTogYW55O1xuICAgICAgbGV0IG5ld0NvbnRlbnRzOiBzdHJpbmc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG9sZERhdGEgPSBhd2FpdCB0aGlzLmxvYWRJZkV4aXN0cyhmaWxlUGF0aCk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06IEFscmVhZHkgZXhpc3RpbmcgZGF0YTogJHtvbGREYXRhfWAsICdzaWxseScpO1xuICAgICAgICBuZXdEYXRhID0gT2JqZWN0LmFzc2lnbihvbGREYXRhLCBkYXRhKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhgU1NFOiBZQU1MU3RvcmFnZTogU3RvcmluZyAke2ZpbGVQYXRofTogQ29tYmluZWQgZGF0YSB0byB3cml0ZTogJHtuZXdEYXRhfWAsICdzaWxseScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZXJyb3IoYFNTRTogWUFNTFN0b3JhZ2U6IEZhaWxlZCB0byBzdG9yZSAke2ZpbGVQYXRofWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiQmFkIGlucHV0XCIsIGZpbGVQYXRoLCBvbGREYXRhLCBkYXRhKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgRHVtcGluZyBjb250ZW50cyBmb3IgJHtmaWxlUGF0aH0gZnJvbSAke2RhdGF9YCk7XG4gICAgICAvLyBjb25zb2xlLmRlYnVnKG9sZERhdGEpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBuZXdDb250ZW50cyA9IHlhbWwuZHVtcChuZXdEYXRhLCB7XG4gICAgICAgICAgc2NoZW1hOiBTQ0hFTUEsXG4gICAgICAgICAgbm9SZWZzOiB0cnVlLFxuICAgICAgICAgIG5vQ29tcGF0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgU1NFOiBZQU1MU3RvcmFnZTogRmFpbGVkIHRvIGR1bXAgJHtmaWxlUGF0aH06ICR7SlNPTi5zdHJpbmdpZnkoZGF0YSl9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBzYXZlICR7ZmlsZVBhdGh9IHdpdGggJHtKU09OLnN0cmluZ2lmeShuZXdEYXRhKX1gLCBlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmRlYnVnKGBXcml0aW5nIHRvICR7ZmlsZVBhdGh9LCBmaWxlIGV4aXN0czogJHtmaWxlRXhpc3RzfWApO1xuXG4gICAgICAvLyBpZiAoZmlsZUV4aXN0cykge1xuICAgICAgLy8gICBjb25zdCBvbGRDb250ZW50czogc3RyaW5nID0gYXdhaXQgdGhpcy5mcy5yZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgLy8gICBjb25zb2xlLmRlYnVnKGBSZXBsYWNpbmcgY29udGVudHMgb2YgJHtmaWxlUGF0aH1gLCBvbGRDb250ZW50cywgbmV3Q29udGVudHMpO1xuICAgICAgLy8gfVxuXG4gICAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBXcml0aW5nIGZpbGVgKTtcbiAgICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06IFdyaXRpbmcgZmlsZTogJHtuZXdDb250ZW50c31gLCAnc2lsbHknKTtcbiAgICAgIGF3YWl0IHRoaXMuZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBuZXdDb250ZW50cywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBFbXB0eSBkYXRhIGdpdmVuLCByZW1vdmluZyBmaWxlYCk7XG4gICAgICBhd2FpdCB0aGlzLmZzLnJlbW92ZShmaWxlUGF0aCk7XG4gICAgfVxuICB9XG59XG5cblxuY29uc3QgU0NIRU1BID0gbmV3IHlhbWwuU2NoZW1hKHtcbiAgaW5jbHVkZTogW3lhbWwuREVGQVVMVF9TQUZFX1NDSEVNQV0sXG5cbiAgLy8gVHJpY2sgYmVjYXVzZSBqcy15YW1sIEFQSSBhcHBlYXJzIHRvIG5vdCBzdXBwb3J0IGF1Z21lbnRpbmcgaW1wbGljaXQgdGFnc1xuICBpbXBsaWNpdDogW1xuICAgIC4uLih5YW1sLkRFRkFVTFRfU0FGRV9TQ0hFTUEgYXMgYW55KS5pbXBsaWNpdCxcbiAgICAuLi5bY3VzdG9tVGltZXN0YW1wVHlwZV0sXG4gIF0sXG59KTtcbiJdfQ==