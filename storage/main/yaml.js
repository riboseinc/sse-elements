import * as log from 'electron-log';
import * as yaml from 'js-yaml';
import { customTimestampType } from './yaml-custom-ts';
export class YAMLStorage {
    constructor(fs) {
        this.fs = fs;
    }
    async load(filePath) {
        log.debug(`SSE: YAMLStorage: Loading ${filePath}`);
        const data = await this.fs.readFile(filePath, { encoding: 'utf8' });
        return yaml.load(data, { schema: SCHEMA });
    }
    async loadIfExists(filePath) {
        let fileExists;
        let oldData;
        try {
            fileExists = (await this.fs.stat(filePath)).isFile() === true;
        }
        catch (e) {
            fileExists = false;
        }
        if (fileExists) {
            oldData = await this.load(filePath);
        }
        else {
            oldData = {};
        }
        return oldData || {};
    }
    async store(filePath, data) {
        log.debug(`SSE: YAMLStorage: Storing ${filePath}`);
        log.silly(`SSE: YAMLStorage: Storing ${filePath}: ${JSON.stringify(data)}`);
        if (data !== undefined && data !== null) {
            // Merge new data into old data; this way if some YAML properties
            // are not supported we will not lose them after the update.
            let newData;
            let oldData;
            let newContents;
            try {
                oldData = await this.loadIfExists(filePath);
                log.silly(`SSE: YAMLStorage: Storing ${filePath}: Already existing data: ${oldData}`);
                newData = Object.assign(oldData, data);
                log.silly(`SSE: YAMLStorage: Storing ${filePath}: Combined data to write: ${newData}`);
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to store ${filePath}`);
                console.error("Bad input", filePath, oldData, data);
                throw e;
            }
            // console.debug(`Dumping contents for ${filePath} from ${data}`);
            // console.debug(oldData);
            try {
                newContents = yaml.dump(newData, {
                    schema: SCHEMA,
                    noRefs: true,
                    noCompatMode: true,
                });
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to dump ${filePath}: ${JSON.stringify(data)}`);
                console.error(`Failed to save ${filePath} with ${JSON.stringify(newData)}`, e);
                return;
            }
            // console.debug(`Writing to ${filePath}, file exists: ${fileExists}`);
            // if (fileExists) {
            //   const oldContents: string = await this.fs.readFile(filePath, { encoding: 'utf8' });
            //   console.debug(`Replacing contents of ${filePath}`, oldContents, newContents);
            // }
            log.debug(`SSE: YAMLStorage: Storing ${filePath}: Writing file`);
            log.silly(`SSE: YAMLStorage: Storing ${filePath}: Writing file: ${newContents}`);
            await this.fs.writeFile(filePath, newContents, { encoding: 'utf8' });
            return data;
        }
        else {
            log.info(`SSE: YAMLStorage: Storing ${filePath}: Empty data given, removing file`);
            await this.fs.remove(filePath);
        }
    }
}
const SCHEMA = new yaml.Schema({
    include: [yaml.DEFAULT_SAFE_SCHEMA],
    // Trick because js-yaml API appears to not support augmenting implicit tags
    implicit: [
        ...yaml.DEFAULT_SAFE_SCHEMA.implicit,
        ...[customTimestampType],
    ],
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFtbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yYWdlL21haW4veWFtbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssR0FBRyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEtBQUssSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUd2RCxNQUFNLE9BQU8sV0FBVztJQUN0QixZQUFvQixFQUFPO1FBQVAsT0FBRSxHQUFGLEVBQUUsQ0FBSztJQUFJLENBQUM7SUFFekIsS0FBSyxDQUFDLElBQUksQ0FBQyxRQUFnQjtRQUNoQyxHQUFHLENBQUMsS0FBSyxDQUFDLDZCQUE2QixRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sSUFBSSxHQUFXLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDNUUsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLENBQUM7SUFFTyxLQUFLLENBQUMsWUFBWSxDQUFDLFFBQWdCO1FBQ3pDLElBQUksVUFBbUIsQ0FBQztRQUN4QixJQUFJLE9BQVksQ0FBQztRQUVqQixJQUFJO1lBQ0YsVUFBVSxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sRUFBRSxLQUFLLElBQUksQ0FBQztTQUMvRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsVUFBVSxHQUFHLEtBQUssQ0FBQztTQUNwQjtRQUVELElBQUksVUFBVSxFQUFFO1lBQ2QsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUNy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QUksQ0FBQyxtQkFBMkIsQ0FBQyxRQUFRO1FBQzdDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQztLQUN6QjtDQUNGLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGxvZyBmcm9tICdlbGVjdHJvbi1sb2cnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICdqcy15YW1sJztcbmltcG9ydCB7IGN1c3RvbVRpbWVzdGFtcFR5cGUgfSBmcm9tICcuL3lhbWwtY3VzdG9tLXRzJztcblxuXG5leHBvcnQgY2xhc3MgWUFNTFN0b3JhZ2Uge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGZzOiBhbnkpIHsgfVxuXG4gIHB1YmxpYyBhc3luYyBsb2FkKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGxvZy5kZWJ1ZyhgU1NFOiBZQU1MU3RvcmFnZTogTG9hZGluZyAke2ZpbGVQYXRofWApO1xuICAgIGNvbnN0IGRhdGE6IHN0cmluZyA9IGF3YWl0IHRoaXMuZnMucmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICByZXR1cm4geWFtbC5sb2FkKGRhdGEsIHsgc2NoZW1hOiBTQ0hFTUEgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRJZkV4aXN0cyhmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICBsZXQgZmlsZUV4aXN0czogYm9vbGVhbjtcbiAgICBsZXQgb2xkRGF0YTogYW55O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZpbGVFeGlzdHMgPSAoYXdhaXQgdGhpcy5mcy5zdGF0KGZpbGVQYXRoKSkuaXNGaWxlKCkgPT09IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZmlsZUV4aXN0cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChmaWxlRXhpc3RzKSB7XG4gICAgICBvbGREYXRhID0gYXdhaXQgdGhpcy5sb2FkKGZpbGVQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2xkRGF0YSA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBvbGREYXRhIHx8IHt9O1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHN0b3JlKGZpbGVQYXRoOiBzdHJpbmcsIGRhdGE6IGFueSk6IFByb21pc2U8YW55PiB7XG4gICAgbG9nLmRlYnVnKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9YCk7XG4gICAgbG9nLnNpbGx5KGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuXG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBNZXJnZSBuZXcgZGF0YSBpbnRvIG9sZCBkYXRhOyB0aGlzIHdheSBpZiBzb21lIFlBTUwgcHJvcGVydGllc1xuICAgICAgLy8gYXJlIG5vdCBzdXBwb3J0ZWQgd2Ugd2lsbCBub3QgbG9zZSB0aGVtIGFmdGVyIHRoZSB1cGRhdGUuXG4gICAgICBsZXQgbmV3RGF0YTogYW55O1xuICAgICAgbGV0IG9sZERhdGE6IGFueTtcbiAgICAgIGxldCBuZXdDb250ZW50czogc3RyaW5nO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvbGREYXRhID0gYXdhaXQgdGhpcy5sb2FkSWZFeGlzdHMoZmlsZVBhdGgpO1xuICAgICAgICBsb2cuc2lsbHkoYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06IEFscmVhZHkgZXhpc3RpbmcgZGF0YTogJHtvbGREYXRhfWApO1xuICAgICAgICBuZXdEYXRhID0gT2JqZWN0LmFzc2lnbihvbGREYXRhLCBkYXRhKTtcbiAgICAgICAgbG9nLnNpbGx5KGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBDb21iaW5lZCBkYXRhIHRvIHdyaXRlOiAke25ld0RhdGF9YCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxvZy5lcnJvcihgU1NFOiBZQU1MU3RvcmFnZTogRmFpbGVkIHRvIHN0b3JlICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJCYWQgaW5wdXRcIiwgZmlsZVBhdGgsIG9sZERhdGEsIGRhdGEpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmRlYnVnKGBEdW1waW5nIGNvbnRlbnRzIGZvciAke2ZpbGVQYXRofSBmcm9tICR7ZGF0YX1gKTtcbiAgICAgIC8vIGNvbnNvbGUuZGVidWcob2xkRGF0YSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ld0NvbnRlbnRzID0geWFtbC5kdW1wKG5ld0RhdGEsIHtcbiAgICAgICAgICBzY2hlbWE6IFNDSEVNQSxcbiAgICAgICAgICBub1JlZnM6IHRydWUsXG4gICAgICAgICAgbm9Db21wYXRNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGBTU0U6IFlBTUxTdG9yYWdlOiBGYWlsZWQgdG8gZHVtcCAke2ZpbGVQYXRofTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX1gKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHNhdmUgJHtmaWxlUGF0aH0gd2l0aCAke0pTT04uc3RyaW5naWZ5KG5ld0RhdGEpfWAsIGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFdyaXRpbmcgdG8gJHtmaWxlUGF0aH0sIGZpbGUgZXhpc3RzOiAke2ZpbGVFeGlzdHN9YCk7XG5cbiAgICAgIC8vIGlmIChmaWxlRXhpc3RzKSB7XG4gICAgICAvLyAgIGNvbnN0IG9sZENvbnRlbnRzOiBzdHJpbmcgPSBhd2FpdCB0aGlzLmZzLnJlYWRGaWxlKGZpbGVQYXRoLCB7IGVuY29kaW5nOiAndXRmOCcgfSk7XG4gICAgICAvLyAgIGNvbnNvbGUuZGVidWcoYFJlcGxhY2luZyBjb250ZW50cyBvZiAke2ZpbGVQYXRofWAsIG9sZENvbnRlbnRzLCBuZXdDb250ZW50cyk7XG4gICAgICAvLyB9XG5cbiAgICAgIGxvZy5kZWJ1ZyhgU1NFOiBZQU1MU3RvcmFnZTogU3RvcmluZyAke2ZpbGVQYXRofTogV3JpdGluZyBmaWxlYCk7XG4gICAgICBsb2cuc2lsbHkoYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06IFdyaXRpbmcgZmlsZTogJHtuZXdDb250ZW50c31gKTtcbiAgICAgIGF3YWl0IHRoaXMuZnMud3JpdGVGaWxlKGZpbGVQYXRoLCBuZXdDb250ZW50cywgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBFbXB0eSBkYXRhIGdpdmVuLCByZW1vdmluZyBmaWxlYCk7XG4gICAgICBhd2FpdCB0aGlzLmZzLnJlbW92ZShmaWxlUGF0aCk7XG4gICAgfVxuICB9XG59XG5cblxuY29uc3QgU0NIRU1BID0gbmV3IHlhbWwuU2NoZW1hKHtcbiAgaW5jbHVkZTogW3lhbWwuREVGQVVMVF9TQUZFX1NDSEVNQV0sXG5cbiAgLy8gVHJpY2sgYmVjYXVzZSBqcy15YW1sIEFQSSBhcHBlYXJzIHRvIG5vdCBzdXBwb3J0IGF1Z21lbnRpbmcgaW1wbGljaXQgdGFnc1xuICBpbXBsaWNpdDogW1xuICAgIC4uLih5YW1sLkRFRkFVTFRfU0FGRV9TQ0hFTUEgYXMgYW55KS5pbXBsaWNpdCxcbiAgICAuLi5bY3VzdG9tVGltZXN0YW1wVHlwZV0sXG4gIF0sXG59KTtcbiJdfQ==