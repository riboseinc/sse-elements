import * as log from 'electron-log';
import * as yaml from 'js-yaml';
import { customTimestampType } from './yaml-custom-ts';
// TODO: Should probably implement locking to avoid race conditions on writes (#4)
export class YAMLStorage {
    constructor(fs, opts = { debugLog: false }) {
        this.fs = fs;
        this.opts = opts;
    }
    debugLog(message, level = 'debug') {
        if (this.opts.debugLog) {
            log[level](message);
        }
    }
    async load(filePath) {
        this.debugLog(`SSE: YAMLStorage: Loading ${filePath}`);
        const data = await this.fs.readFile(filePath, { encoding: 'utf8' });
        return yaml.load(data, { schema: SCHEMA });
    }
    async loadIfExists(filePath) {
        let fileExists;
        let oldData;
        try {
            fileExists = (await this.fs.stat(filePath)).isFile() === true;
        }
        catch (e) {
            fileExists = false;
        }
        if (fileExists) {
            oldData = await this.load(filePath);
        }
        else {
            oldData = {};
        }
        return oldData || {};
    }
    async store(filePath, data) {
        this.debugLog(`SSE: YAMLStorage: Storing ${filePath}`);
        this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: ${JSON.stringify(data)}`, 'silly');
        if (data !== undefined && data !== null) {
            // Merge new data into old data; this way if some YAML properties
            // are not supported we will not lose them after the update.
            let newData;
            let oldData;
            let newContents;
            try {
                oldData = await this.loadIfExists(filePath);
                this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Already existing data: ${oldData}`, 'silly');
                newData = Object.assign(oldData, data);
                this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Combined data to write: ${newData}`, 'silly');
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to store ${filePath}`);
                console.error("Bad input", filePath, oldData, data);
                throw e;
            }
            // console.debug(`Dumping contents for ${filePath} from ${data}`);
            // console.debug(oldData);
            try {
                newContents = yaml.dump(newData, {
                    schema: SCHEMA,
                    noRefs: true,
                    noCompatMode: true,
                });
            }
            catch (e) {
                log.error(`SSE: YAMLStorage: Failed to dump ${filePath}: ${JSON.stringify(data)}`);
                console.error(`Failed to save ${filePath} with ${JSON.stringify(newData)}`, e);
                return;
            }
            // console.debug(`Writing to ${filePath}, file exists: ${fileExists}`);
            // if (fileExists) {
            //   const oldContents: string = await this.fs.readFile(filePath, { encoding: 'utf8' });
            //   console.debug(`Replacing contents of ${filePath}`, oldContents, newContents);
            // }
            this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Writing file`);
            this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Writing file: ${newContents}`, 'silly');
            await this.fs.writeFile(filePath, newContents, { encoding: 'utf8' });
            return data;
        }
        else {
            this.debugLog(`SSE: YAMLStorage: Storing ${filePath}: Empty data given, removing file`);
            await this.fs.remove(filePath);
        }
    }
}
const SCHEMA = new yaml.Schema({
    include: [yaml.DEFAULT_SAFE_SCHEMA],
    // Trick because js-yaml API appears to not support augmenting implicit tags
    implicit: [
        ...yaml.DEFAULT_SAFE_SCHEMA.implicit,
        ...[customTimestampType],
    ],
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoieWFtbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yYWdlL21haW4veWFtbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssR0FBRyxNQUFNLGNBQWMsQ0FBQztBQUNwQyxPQUFPLEtBQUssSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQVF2RCxrRkFBa0Y7QUFDbEYsTUFBTSxPQUFPLFdBQVc7SUFDdEIsWUFBb0IsRUFBTyxFQUFVLE9BQTJCLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRTtRQUEvRCxPQUFFLEdBQUYsRUFBRSxDQUFLO1FBQVUsU0FBSSxHQUFKLElBQUksQ0FBMEM7SUFBSSxDQUFDO0lBRWhGLFFBQVEsQ0FBQyxPQUFlLEVBQUUsUUFBMkIsT0FBTztRQUNsRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ3RCLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNyQjtJQUNILENBQUM7SUFFTSxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQWdCO1FBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsNkJBQTZCLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDdkQsTUFBTSxJQUFJLEdBQVcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUM1RSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVPLEtBQUssQ0FBQyxZQUFZLENBQUMsUUFBZ0I7UUFDekMsSUFBSSxVQUFtQixDQUFDO1FBQ3hCLElBQUksT0FBWSxDQUFDO1FBRWpCLElBQUk7WUFDRixVQUFVLEdBQUcsQ0FBQyxN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SUFBSSxDQUFDLFFBQVEsQ0FBQyw2QkFBNkIsUUFBUSxtQ0FBbUMsQ0FBQyxDQUFDO1lBQ3hGLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDaEM7SUFDSCxDQUFDO0NBQ0Y7QUFHRCxNQUFNLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDN0IsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDO0lBRW5DLDRFQUE0RTtJQUM1RSxRQUFRLEVBQUU7UUFDUixHQUFJLElBQUksQ0FBQyxtQkFBMkIsQ0FBQyxRQUFRO1FBQzdDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQztLQUN6QjtDQUNGLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGxvZyBmcm9tICdlbGVjdHJvbi1sb2cnO1xuaW1wb3J0ICogYXMgeWFtbCBmcm9tICdqcy15YW1sJztcbmltcG9ydCB7IGN1c3RvbVRpbWVzdGFtcFR5cGUgfSBmcm9tICcuL3lhbWwtY3VzdG9tLXRzJztcblxuXG5pbnRlcmZhY2UgWUFNTFN0b3JhZ2VPcHRpb25zIHtcbiAgZGVidWdMb2c6IGJvb2xlYW47XG59XG5cblxuLy8gVE9ETzogU2hvdWxkIHByb2JhYmx5IGltcGxlbWVudCBsb2NraW5nIHRvIGF2b2lkIHJhY2UgY29uZGl0aW9ucyBvbiB3cml0ZXMgKCM0KVxuZXhwb3J0IGNsYXNzIFlBTUxTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBmczogYW55LCBwcml2YXRlIG9wdHM6IFlBTUxTdG9yYWdlT3B0aW9ucyA9IHsgZGVidWdMb2c6IGZhbHNlIH0pIHsgfVxuXG4gIHByaXZhdGUgZGVidWdMb2cobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogJ3NpbGx5JyB8ICdkZWJ1ZycgPSAnZGVidWcnKSB7XG4gICAgaWYgKHRoaXMub3B0cy5kZWJ1Z0xvZykge1xuICAgICAgbG9nW2xldmVsXShtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbG9hZChmaWxlUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBMb2FkaW5nICR7ZmlsZVBhdGh9YCk7XG4gICAgY29uc3QgZGF0YTogc3RyaW5nID0gYXdhaXQgdGhpcy5mcy5yZWFkRmlsZShmaWxlUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICAgIHJldHVybiB5YW1sLmxvYWQoZGF0YSwgeyBzY2hlbWE6IFNDSEVNQSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgbG9hZElmRXhpc3RzKGZpbGVQYXRoOiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgIGxldCBmaWxlRXhpc3RzOiBib29sZWFuO1xuICAgIGxldCBvbGREYXRhOiBhbnk7XG5cbiAgICB0cnkge1xuICAgICAgZmlsZUV4aXN0cyA9IChhd2FpdCB0aGlzLmZzLnN0YXQoZmlsZVBhdGgpKS5pc0ZpbGUoKSA9PT0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBmaWxlRXhpc3RzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgIG9sZERhdGEgPSBhd2FpdCB0aGlzLmxvYWQoZmlsZVBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbGREYXRhID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIG9sZERhdGEgfHwge307XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgc3RvcmUoZmlsZVBhdGg6IHN0cmluZywgZGF0YTogYW55KTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9YClcbiAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWAsICdzaWxseScpO1xuXG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICAvLyBNZXJnZSBuZXcgZGF0YSBpbnRvIG9sZCBkYXRhOyB0aGlzIHdheSBpZiBzb21lIFlBTUwgcHJvcGVydGllc1xuICAgICAgLy8gYXJlIG5vdCBzdXBwb3J0ZWQgd2Ugd2lsbCBub3QgbG9zZSB0aGVtIGFmdGVyIHRoZSB1cGRhdGUuXG4gICAgICBsZXQgbmV3RGF0YTogYW55O1xuICAgICAgbGV0IG9sZERhdGE6IGFueTtcbiAgICAgIGxldCBuZXdDb250ZW50czogc3RyaW5nO1xuXG4gICAgICB0cnkge1xuICAgICAgICBvbGREYXRhID0gYXdhaXQgdGhpcy5sb2FkSWZFeGlzdHMoZmlsZVBhdGgpO1xuICAgICAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBBbHJlYWR5IGV4aXN0aW5nIGRhdGE6ICR7b2xkRGF0YX1gLCAnc2lsbHknKTtcbiAgICAgICAgbmV3RGF0YSA9IE9iamVjdC5hc3NpZ24ob2xkRGF0YSwgZGF0YSk7XG4gICAgICAgIHRoaXMuZGVidWdMb2coYFNTRTogWUFNTFN0b3JhZ2U6IFN0b3JpbmcgJHtmaWxlUGF0aH06IENvbWJpbmVkIGRhdGEgdG8gd3JpdGU6ICR7bmV3RGF0YX1gLCAnc2lsbHknKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nLmVycm9yKGBTU0U6IFlBTUxTdG9yYWdlOiBGYWlsZWQgdG8gc3RvcmUgJHtmaWxlUGF0aH1gKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkJhZCBpbnB1dFwiLCBmaWxlUGF0aCwgb2xkRGF0YSwgZGF0YSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUuZGVidWcoYER1bXBpbmcgY29udGVudHMgZm9yICR7ZmlsZVBhdGh9IGZyb20gJHtkYXRhfWApO1xuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhvbGREYXRhKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Q29udGVudHMgPSB5YW1sLmR1bXAobmV3RGF0YSwge1xuICAgICAgICAgIHNjaGVtYTogU0NIRU1BLFxuICAgICAgICAgIG5vUmVmczogdHJ1ZSxcbiAgICAgICAgICBub0NvbXBhdE1vZGU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsb2cuZXJyb3IoYFNTRTogWUFNTFN0b3JhZ2U6IEZhaWxlZCB0byBkdW1wICR7ZmlsZVBhdGh9OiAke0pTT04uc3RyaW5naWZ5KGRhdGEpfWApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gc2F2ZSAke2ZpbGVQYXRofSB3aXRoICR7SlNPTi5zdHJpbmdpZnkobmV3RGF0YSl9YCwgZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5kZWJ1ZyhgV3JpdGluZyB0byAke2ZpbGVQYXRofSwgZmlsZSBleGlzdHM6ICR7ZmlsZUV4aXN0c31gKTtcblxuICAgICAgLy8gaWYgKGZpbGVFeGlzdHMpIHtcbiAgICAgIC8vICAgY29uc3Qgb2xkQ29udGVudHM6IHN0cmluZyA9IGF3YWl0IHRoaXMuZnMucmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgIC8vICAgY29uc29sZS5kZWJ1ZyhgUmVwbGFjaW5nIGNvbnRlbnRzIG9mICR7ZmlsZVBhdGh9YCwgb2xkQ29udGVudHMsIG5ld0NvbnRlbnRzKTtcbiAgICAgIC8vIH1cblxuICAgICAgdGhpcy5kZWJ1Z0xvZyhgU1NFOiBZQU1MU3RvcmFnZTogU3RvcmluZyAke2ZpbGVQYXRofTogV3JpdGluZyBmaWxlYCk7XG4gICAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBXcml0aW5nIGZpbGU6ICR7bmV3Q29udGVudHN9YCwgJ3NpbGx5Jyk7XG4gICAgICBhd2FpdCB0aGlzLmZzLndyaXRlRmlsZShmaWxlUGF0aCwgbmV3Q29udGVudHMsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlYnVnTG9nKGBTU0U6IFlBTUxTdG9yYWdlOiBTdG9yaW5nICR7ZmlsZVBhdGh9OiBFbXB0eSBkYXRhIGdpdmVuLCByZW1vdmluZyBmaWxlYCk7XG4gICAgICBhd2FpdCB0aGlzLmZzLnJlbW92ZShmaWxlUGF0aCk7XG4gICAgfVxuICB9XG59XG5cblxuY29uc3QgU0NIRU1BID0gbmV3IHlhbWwuU2NoZW1hKHtcbiAgaW5jbHVkZTogW3lhbWwuREVGQVVMVF9TQUZFX1NDSEVNQV0sXG5cbiAgLy8gVHJpY2sgYmVjYXVzZSBqcy15YW1sIEFQSSBhcHBlYXJzIHRvIG5vdCBzdXBwb3J0IGF1Z21lbnRpbmcgaW1wbGljaXQgdGFnc1xuICBpbXBsaWNpdDogW1xuICAgIC4uLih5YW1sLkRFRkFVTFRfU0FGRV9TQ0hFTUEgYXMgYW55KS5pbXBsaWNpdCxcbiAgICAuLi5bY3VzdG9tVGltZXN0YW1wVHlwZV0sXG4gIF0sXG59KTtcbiJdfQ==