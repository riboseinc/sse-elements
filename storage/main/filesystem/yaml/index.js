import * as path from 'path';
import * as fs from 'fs-extra';
import * as yaml from 'js-yaml';
import { Schema } from './schema';
import { AbstractLockingFilesystemBackend } from '../base';
const YAML_EXT = '.yaml';
class YAMLBackend extends AbstractLockingFilesystemBackend {
    isYAMLFile(objId) {
        return path.extname(objId) === YAML_EXT;
    }
    async isValidId(objId) {
        return this.isYAMLFile(objId);
    }
    async resolveObjectId(objId) {
        // Drop YAML extension from resolved path fragment.
        const idWithExt = await super.resolveObjectId(objId);
        return path.basename(idWithExt, YAML_EXT);
    }
    expandPath(objId) {
        // In this case, path to object should include YAML extension.
        return `${super.expandPath(objId)}${YAML_EXT}`;
    }
    parseData(data) {
        return yaml.load(data, { schema: Schema });
    }
    dumpData(data) {
        if (data !== undefined && data !== null) {
            return yaml.dump(data, {
                schema: Schema,
                noRefs: true,
                noCompatMode: true,
            });
        }
        else {
            throw new Error("Attempt to write invalid data (null or undefined)");
        }
    }
}
;
export class YAMLDirectoryBackend extends YAMLBackend {
    constructor(baseDir, metaProperties) {
        super(baseDir);
        this.metaProperties = metaProperties;
    }
    expandDirectoryPath(objId) {
        return path.join(this.baseDir, objId);
    }
    async exists(objId) {
        const dirPath = this.expandDirectoryPath(objId);
        if (await fs.pathExists(dirPath)) {
            const stat = await fs.stat(dirPath);
            if (!stat.isDirectory()) {
                throw new Error("File is expected to be a directory");
            }
            return true;
        }
        return false;
    }
    async isValidId(value) {
        const metaFile = path.join(this.expandDirectoryPath(value), `meta${YAML_EXT}`);
        let metaFileIsFile;
        try {
            metaFileIsFile = (await fs.stat(metaFile)).isFile();
        }
        catch (e) {
            return false;
        }
        if (!metaFileIsFile) {
            return false;
        }
        return metaFileIsFile;
    }
    async read(objId) {
        const objAbsPath = this.expandDirectoryPath(objId);
        const metaId = 'meta';
        const metaAbsPath = path.join(objAbsPath, `${metaId}${YAML_EXT}`);
        let metaFileIsFile;
        try {
            metaFileIsFile = (await fs.stat(metaAbsPath)).isFile();
        }
        catch (e) {
            throw new Error(`Exception accessing meta file for ${objId}: ${metaAbsPath}: ${e.toString()} ${e.stack}`);
        }
        if (!metaFileIsFile) {
            throw new Error(`Meta file for ${objId} is not a file: ${metaAbsPath}`);
        }
        var objData = {};
        const metaPath = path.join(objId, metaId);
        const meta = await super.read(metaPath) || {};
        for (const key of this.metaProperties) {
            objData[key] = meta[key];
        }
        const dirContents = await fs.readdir(objAbsPath);
        for (const filename of dirContents) {
            if (this.isYAMLFile(filename)) {
                const fieldName = path.basename(filename, YAML_EXT);
                if (fieldName != 'meta') {
                    objData[fieldName] = await super.read(path.join(objId, fieldName));
                }
            }
        }
        // Blindly hope that data structure loaded from YAML
        // is valid for given type.
        return objData;
    }
    async write(objId, newData) {
        const objPath = this.expandDirectoryPath(objId);
        await fs.ensureDir(objPath);
        var dataToStore = { meta: {} };
        var modifiedPaths = [];
        for (const key of Object.keys(newData)) {
            if (this.metaProperties.indexOf(key) >= 0) {
                dataToStore.meta[key] = newData[key];
            }
            else {
                dataToStore[key] = newData[key];
            }
        }
        for (const [fieldName, fieldValue] of Object.entries(dataToStore)) {
            modifiedPaths = [
                ...modifiedPaths,
                ...(await super.write(path.join(objId, fieldName), fieldValue)),
            ];
        }
        return modifiedPaths;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvc3RvcmFnZS9tYWluL2ZpbGVzeXN0ZW0veWFtbC9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUM3QixPQUFPLEtBQUssRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUMvQixPQUFPLEtBQUssSUFBSSxNQUFNLFNBQVMsQ0FBQztBQUNoQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sVUFBVSxDQUFDO0FBRWxDLE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLFNBQVMsQ0FBQztBQUczRCxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUM7QUFHekIsTUFBTSxXQUFxQixTQUFRLGdDQUFtQztJQUMxRCxVQUFVLENBQUMsS0FBYTtRQUNoQyxPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssUUFBUSxDQUFDO0lBQzFDLENBQUM7SUFFTSxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQWE7UUFDbEMsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFFTSxLQUFLLENBQUMsZUFBZSxDQUFDLEtBQWE7UUFDeEMsbURBQW1EO1FBQ25ELE1BQU0sU0FBUyxHQUFHLE1BQU0sS0FBSyxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNyRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzVDLENBQUM7SUFFTSxVQUFVLENBQUMsS0FBYTtRQUM3Qiw4REFBOEQ7UUFDOUQsT0FBTyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxFQUFFLENBQUM7SUFDakQsQ0FBQztJQUVTLFNBQVMsQ0FBQyxJQUFZO1FBQzlCLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxJ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QUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQztRQUMvRCxJQUFJLGFBQWEsR0FBRyxFQUFjLENBQUM7UUFFbkMsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ3RDLElBQUksSUFBSSxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUN6QyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQzthQUN0QztpQkFBTTtnQkFDTCxXQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQ2pDO1NBQ0Y7UUFFRCxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUNqRSxhQUFhLEdBQUc7Z0JBQ2QsR0FBRyxhQUFhO2dCQUNoQixHQUFHLENBQUMsTUFBTSxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDO2FBQ2hFLENBQUM7U0FDSDtRQUVELE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgKiBhcyB5YW1sIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHsgU2NoZW1hIH0gZnJvbSAnLi9zY2hlbWEnO1xuXG5pbXBvcnQgeyBBYnN0cmFjdExvY2tpbmdGaWxlc3lzdGVtQmFja2VuZCB9IGZyb20gJy4uL2Jhc2UnO1xuXG5cbmNvbnN0IFlBTUxfRVhUID0gJy55YW1sJztcblxuXG5jbGFzcyBZQU1MQmFja2VuZDxUID0gYW55PiBleHRlbmRzIEFic3RyYWN0TG9ja2luZ0ZpbGVzeXN0ZW1CYWNrZW5kPFQ+IHtcbiAgcHJvdGVjdGVkIGlzWUFNTEZpbGUob2JqSWQ6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLmV4dG5hbWUob2JqSWQpID09PSBZQU1MX0VYVDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpc1ZhbGlkSWQob2JqSWQ6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmlzWUFNTEZpbGUob2JqSWQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlc29sdmVPYmplY3RJZChvYmpJZDogc3RyaW5nKSB7XG4gICAgLy8gRHJvcCBZQU1MIGV4dGVuc2lvbiBmcm9tIHJlc29sdmVkIHBhdGggZnJhZ21lbnQuXG4gICAgY29uc3QgaWRXaXRoRXh0ID0gYXdhaXQgc3VwZXIucmVzb2x2ZU9iamVjdElkKG9iaklkKTtcbiAgICByZXR1cm4gcGF0aC5iYXNlbmFtZShpZFdpdGhFeHQsIFlBTUxfRVhUKTtcbiAgfVxuXG4gIHB1YmxpYyBleHBhbmRQYXRoKG9iaklkOiBzdHJpbmcpIHtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHBhdGggdG8gb2JqZWN0IHNob3VsZCBpbmNsdWRlIFlBTUwgZXh0ZW5zaW9uLlxuICAgIHJldHVybiBgJHtzdXBlci5leHBhbmRQYXRoKG9iaklkKX0ke1lBTUxfRVhUfWA7XG4gIH1cblxuICBwcm90ZWN0ZWQgcGFyc2VEYXRhKGRhdGE6IHN0cmluZyk6IGFueSB7XG4gICAgcmV0dXJuIHlhbWwubG9hZChkYXRhLCB7IHNjaGVtYTogU2NoZW1hIH0pO1xuICB9XG5cbiAgcHJvdGVjdGVkIGR1bXBEYXRhKGRhdGE6IGFueSk6IHN0cmluZyB7XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4geWFtbC5kdW1wKGRhdGEsIHtcbiAgICAgICAgc2NoZW1hOiBTY2hlbWEsXG4gICAgICAgIG5vUmVmczogdHJ1ZSxcbiAgICAgICAgbm9Db21wYXRNb2RlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBpbnZhbGlkIGRhdGEgKG51bGwgb3IgdW5kZWZpbmVkKVwiKTtcblxuICAgIH1cbiAgfVxufVxuXG5cbmludGVyZmFjZSBZQU1MRGlyZWN0b3J5U3RvcmVhYmxlQ29udGVudHMge1xuICBtZXRhOiBhbnksXG4gIFtrZXk6IHN0cmluZ106IGFueSxcbn07XG5cbmV4cG9ydCBjbGFzcyBZQU1MRGlyZWN0b3J5QmFja2VuZCBleHRlbmRzIFlBTUxCYWNrZW5kPFlBTUxEaXJlY3RvcnlTdG9yZWFibGVDb250ZW50cz4ge1xuXG4gIGNvbnN0cnVjdG9yKGJhc2VEaXI6IHN0cmluZywgcHJpdmF0ZSBtZXRhUHJvcGVydGllczogc3RyaW5nW10pIHsgc3VwZXIoYmFzZURpcik7IH1cblxuICBwcml2YXRlIGV4cGFuZERpcmVjdG9yeVBhdGgob2JqSWQ6IHN0cmluZykge1xuICAgIHJldHVybiBwYXRoLmpvaW4odGhpcy5iYXNlRGlyLCBvYmpJZCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZXhpc3RzKG9iaklkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBkaXJQYXRoID0gdGhpcy5leHBhbmREaXJlY3RvcnlQYXRoKG9iaklkKTtcbiAgICBpZiAoYXdhaXQgZnMucGF0aEV4aXN0cyhkaXJQYXRoKSkge1xuICAgICAgY29uc3Qgc3RhdCA9IGF3YWl0IGZzLnN0YXQoZGlyUGF0aCk7XG4gICAgICBpZiAoIXN0YXQuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWxlIGlzIGV4cGVjdGVkIHRvIGJlIGEgZGlyZWN0b3J5XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBpc1ZhbGlkSWQodmFsdWU6IHN0cmluZykge1xuICAgIGNvbnN0IG1ldGFGaWxlID0gcGF0aC5qb2luKHRoaXMuZXhwYW5kRGlyZWN0b3J5UGF0aCh2YWx1ZSksIGBtZXRhJHtZQU1MX0VYVH1gKTtcbiAgICBsZXQgbWV0YUZpbGVJc0ZpbGU6IGJvb2xlYW47XG4gICAgdHJ5IHtcbiAgICAgIG1ldGFGaWxlSXNGaWxlID0gKGF3YWl0IGZzLnN0YXQobWV0YUZpbGUpKS5pc0ZpbGUoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghbWV0YUZpbGVJc0ZpbGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGFGaWxlSXNGaWxlO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWQob2JqSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IG9iakFic1BhdGggPSB0aGlzLmV4cGFuZERpcmVjdG9yeVBhdGgob2JqSWQpO1xuXG4gICAgY29uc3QgbWV0YUlkID0gJ21ldGEnO1xuXG4gICAgY29uc3QgbWV0YUFic1BhdGggPSBwYXRoLmpvaW4ob2JqQWJzUGF0aCwgYCR7bWV0YUlkfSR7WUFNTF9FWFR9YCk7XG4gICAgbGV0IG1ldGFGaWxlSXNGaWxlOiBib29sZWFuO1xuICAgIHRyeSB7XG4gICAgICBtZXRhRmlsZUlzRmlsZSA9IChhd2FpdCBmcy5zdGF0KG1ldGFBYnNQYXRoKSkuaXNGaWxlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeGNlcHRpb24gYWNjZXNzaW5nIG1ldGEgZmlsZSBmb3IgJHtvYmpJZH06ICR7bWV0YUFic1BhdGh9OiAke2UudG9TdHJpbmcoKX0gJHtlLnN0YWNrfWApO1xuICAgIH1cbiAgICBpZiAoIW1ldGFGaWxlSXNGaWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE1ldGEgZmlsZSBmb3IgJHtvYmpJZH0gaXMgbm90IGEgZmlsZTogJHttZXRhQWJzUGF0aH1gKTtcbiAgICB9XG5cbiAgICB2YXIgb2JqRGF0YTogYW55ID0ge307XG5cbiAgICBjb25zdCBtZXRhUGF0aCA9IHBhdGguam9pbihvYmpJZCwgbWV0YUlkKTtcbiAgICBjb25zdCBtZXRhID0gYXdhaXQgc3VwZXIucmVhZChtZXRhUGF0aCkgfHwge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5tZXRhUHJvcGVydGllcykge1xuICAgICAgb2JqRGF0YVtrZXldID0gbWV0YVtrZXldO1xuICAgIH1cblxuICAgIGNvbnN0IGRpckNvbnRlbnRzID0gYXdhaXQgZnMucmVhZGRpcihvYmpBYnNQYXRoKTtcbiAgICBmb3IgKGNvbnN0IGZpbGVuYW1lIG9mIGRpckNvbnRlbnRzKSB7XG4gICAgICBpZiAodGhpcy5pc1lBTUxGaWxlKGZpbGVuYW1lKSkge1xuICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lLCBZQU1MX0VYVCk7XG4gICAgICAgIGlmIChmaWVsZE5hbWUgIT0gJ21ldGEnKSB7XG4gICAgICAgICAgb2JqRGF0YVtmaWVsZE5hbWVdID0gYXdhaXQgc3VwZXIucmVhZChwYXRoLmpvaW4ob2JqSWQsIGZpZWxkTmFtZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmxpbmRseSBob3BlIHRoYXQgZGF0YSBzdHJ1Y3R1cmUgbG9hZGVkIGZyb20gWUFNTFxuICAgIC8vIGlzIHZhbGlkIGZvciBnaXZlbiB0eXBlLlxuICAgIHJldHVybiBvYmpEYXRhO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHdyaXRlKG9iaklkOiBzdHJpbmcsIG5ld0RhdGE6IGFueSkge1xuICAgIGNvbnN0IG9ialBhdGggPSB0aGlzLmV4cGFuZERpcmVjdG9yeVBhdGgob2JqSWQpO1xuXG4gICAgYXdhaXQgZnMuZW5zdXJlRGlyKG9ialBhdGgpO1xuXG4gICAgdmFyIGRhdGFUb1N0b3JlOiBZQU1MRGlyZWN0b3J5U3RvcmVhYmxlQ29udGVudHMgPSB7IG1ldGE6IHt9IH07XG4gICAgdmFyIG1vZGlmaWVkUGF0aHMgPSBbXSBhcyBzdHJpbmdbXTtcblxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG5ld0RhdGEpKSB7XG4gICAgICBpZiAodGhpcy5tZXRhUHJvcGVydGllcy5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICBkYXRhVG9TdG9yZS5tZXRhW2tleV0gPSBuZXdEYXRhW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhVG9TdG9yZVtrZXldID0gbmV3RGF0YVtrZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRWYWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YVRvU3RvcmUpKSB7XG4gICAgICBtb2RpZmllZFBhdGhzID0gW1xuICAgICAgICAuLi5tb2RpZmllZFBhdGhzLFxuICAgICAgICAuLi4oYXdhaXQgc3VwZXIud3JpdGUocGF0aC5qb2luKG9iaklkLCBmaWVsZE5hbWUpLCBmaWVsZFZhbHVlKSksXG4gICAgICBdO1xuICAgIH1cblxuICAgIHJldHVybiBtb2RpZmllZFBhdGhzO1xuICB9XG59XG4iXX0=