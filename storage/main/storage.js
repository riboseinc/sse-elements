import * as path from 'path';
import { makeEndpoint } from '../../api/main';
import { YAMLStorage } from './yaml';
const YAML_EXT = '.yaml';
export class StoreManager {
    constructor(rootDir) {
        this.rootDir = rootDir;
        this._index = undefined;
    }
    async storeIndex(storage, newIdx) {
        const idx = newIdx || await this.getIndex(storage);
        const items = Object.values(idx);
        for (const obj of items) {
            await this.store(obj, storage, false);
        }
        this._index = idx;
        return true;
    }
    async getIndex(storage) {
        if (this._index === undefined) {
            this._index = await this._loadIndex(storage);
        }
        return this._index;
    }
    async findObjects(storage, query) {
        const index = await this.getIndex(storage);
        if (query !== undefined) {
            var results = {};
            for (let key of Object.keys(index)) {
                const obj = index[key];
                if (this.objectMatchesQuery(obj, query)) {
                    results[key] = obj;
                }
            }
            return results;
        }
        else {
            return index;
        }
    }
    async _loadIndex(storage) {
        const rootPath = this.rootDir;
        const dirs = await storage.fs.readdir(path.join(storage.workDir, rootPath));
        var idx = {};
        for (const dir of dirs) {
            if (dir != '.DS_Store') {
                const objData = await storage.loadObject(path.join(rootPath, dir));
                if (objData) {
                    const obj = this.postLoad(objData);
                    if (obj.id) {
                        idx[obj.id] = obj;
                    }
                }
            }
        }
        return idx;
    }
    // TODO: Use `toUseableObject(data: any) => O` to post-process loaded data
    // Stores object in DB
    async store(obj, storage, updateIndex = true) {
        const objDir = path.join(this.rootDir, `${obj.id}`);
        const objPath = path.join(storage.workDir, objDir);
        const storeable = this.toStoreableObject(obj);
        await storage.fs.ensureDir(objPath);
        for (const key of Object.keys(storeable)) {
            const data = storeable[key];
            await storage.yaml.store(path.join(objPath, `${key}.yaml`), data);
        }
        if (updateIndex === true) {
            await this.updateIndexedItem(obj, storage);
        }
        return true;
    }
    async updateIndexedItem(obj, storage) {
        await this.getIndex(storage);
        this._index[obj.id] = obj;
    }
    toStoreableObject(obj) {
        return { meta: obj };
    }
    ;
    // Converts object data into valid object, if needed
    // (in cases when partial data is stored or migration took place previously)
    postLoad(obj) {
        return obj;
    }
    objectMatchesQuery(obj, query) {
        return false;
    }
}
export class Storage {
    constructor(fs, workDir, storeManagers) {
        this.fs = fs;
        this.workDir = workDir;
        this.storeManagers = storeManagers;
        this.fs = fs;
        this.workDir = workDir;
        this.yaml = new YAMLStorage(fs);
        this.workspace = Object.keys(storeManagers).reduce((obj, key) => {
            obj[key] = {};
            return obj;
        }, {});
    }
    async loadWorkspace() {
        this.workspace = await Object.keys(this.storeManagers).reduce(async (objP, key) => {
            const obj = await objP;
            obj[key] = await this.storeManagers[key].getIndex(this);
            return obj;
        }, Promise.resolve({}));
    }
    async storeWorkspace() {
        return Promise.all([...Object.keys(this.storeManagers).map(async (key) => {
                return await this.storeManagers[key].storeIndex(this, this.workspace[key]);
            })]).then(() => true);
    }
    // Loads object data from given directory, reading YAML files.
    // meta.yaml is treated specially, populating top-level object payload.
    // Other YAML files populate corresponding object properties.
    async loadObject(objDir) {
        let objData;
        const metaFile = path.join(this.workDir, objDir, 'meta.yaml');
        let metaFileIsFile;
        try {
            metaFileIsFile = (await this.fs.stat(metaFile)).isFile();
        }
        catch (e) {
            return undefined;
        }
        if (!metaFileIsFile) {
            return undefined;
        }
        objData = await this.yaml.load(metaFile);
        const dirContents = await this.fs.readdir(path.join(this.workDir, objDir));
        for (const item of dirContents) {
            if (path.extname(item) == YAML_EXT) {
                const basename = path.basename(item, YAML_EXT);
                if (basename != 'meta') {
                    objData[basename] = await this.yaml.load(path.join(this.workDir, objDir, item));
                }
            }
        }
        // Blindly hope that data structure loaded from YAML
        // is valid for given type.
        return objData;
    }
    setUpAPIEndpoints(notifier) {
        for (let indexName of Object.keys(this.workspace)) {
            makeEndpoint(`storage-${indexName}-all`, async () => {
                return this.workspace[indexName];
            }, async ({ newData, notify }) => {
                await this.storeManagers[indexName].storeIndex(this, newData);
                notifier([indexName, ...(notify || [])]);
            });
            makeEndpoint(`storage-${indexName}`, async ({ objectId }) => {
                return this.workspace[indexName][objectId];
            }, async ({ newData, notify }) => {
                await this.storeManagers[indexName].store(newData, this);
                notifier([indexName, ...(notify || [])]);
            });
            makeEndpoint(`storage-${indexName}-delete`, async ({ objectId }) => {
                delete this.workspace[indexName][objectId];
                await this.storeManagers[indexName].storeIndex(this, this.workspace[indexName]);
                return true;
            });
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zdG9yYWdlL21haW4vc3RvcmFnZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUU3QixPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFLOUMsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUdyQyxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUM7QUFHekIsTUFBTSxPQUFnQixZQUFZO0lBR2hDLFlBQW1CLE9BQWU7UUFBZixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBRnhCLFdBQU0sR0FBeUIsU0FBUyxDQUFDO0lBRWQsQ0FBQztJQUUvQixLQUFLLENBQUMsVUFBVSxDQUFDLE9BQXFCLEVBQUUsTUFBNEI7UUFDekUsTUFBTSxHQUFHLEdBQWEsTUFBTSxJQUFJLE1BQU0sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM3RCxNQUFNLEtBQUssR0FBUSxNQUFNLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXRDLEtBQUssTUFBTSxHQUFHLElBQUksS0FBSyxFQUFFO1lBQ3ZCLE1BQU0sSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsSUFBSSxDQUFDLE1BQU0sR0FBRyxHQUFHLENBQUM7UUFDbEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxPQUFxQjtRQUN6QyxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQzdCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1NBQzlDO1FBQ0QsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3JCLENBQUM7SUFFTSxLQUFLLENBQUMsV0FBVyxDQUFDLE9BQXFCLEVBQUUsS0FBYztRQUM1RCxNQUFNLEtBQUssR0FBRyxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDM0MsSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3ZCLElBQUksT0FBTyxHQUFhLEVBQUUsQ0FBQztZQUMzQixLQUFLLElBQUksR0FBRyxJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ2xDLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQTtnQkFDdEIsSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFO29CQUN2QyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO2lCQUNwQjthQUNGO1lBQ0QsT0FBTyxPQUFPLENBQUM7U0FDaEI7YUFBTTtZQUNMLE9BQU8sS0FBSyxDQUFDO1NBQ2Q7SUFDSCxDQUFDO0lBRU8sS0FBSyxDQUFDLFVBQVUsQ0FBQyxPQUFxQjtRQUM1QyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzlCLE1BQU0sSUFBSSxHQUFHLE1BQU0sT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFDNUUsSUFBSSxHQUFHLEdBQWEsRUFBRSxDQUFDO1FBRXZCLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3RCLElBQUksR0FBRyxJQUFJLFdBQVcsRUFBRTtnQkFDdEIsTUFBTSxPQUFPLEdBQUcsTUFBTSxPQUFPLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ25FLElBQUksT0FBTyxFQUFFO29CQUNYLE1BQU0sR0FBRyxHQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3RDLElBQUksR0FBRyxDQUFDLEVBQUUsRUFBRTt3QkFDVixHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztxQkFDbkI7aUJBQ0Y7YUFDRjtTQUNGO1FBQ0QsT0FBTyxHQUFHLENBQUM7SUFDYixDQUFDO0lBRUQsMEVBQTBFO0lBRTFFLHNCQUFzQjtJQUNmLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBTSxFQUFFLE9BQXFCLEVBQUUsV0FBVyxHQUFHLElBQUk7UUFDbEUsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQ25ELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUU5QyxNQUFNLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BDLEtBQUssTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN4QyxNQUFNLElBQUksR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUIsTUFBTSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDbkU7UUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFJLEVBQUU7WUFDeEIsTUFBTSxJQUFJLENBQUMsaUJBQWlCLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1NBQzVDO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sS0FBSyxDQUFDLGlCQUFpQixDQUFDLEdBQU0sRUFBRSxPQUFxQjtRQUMxRCxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDNUIsSUFBSSxDQUFDLE1BQW1CLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUMxQyxDQUFDO0lBRU0saUJBQWlCLENBQUMsR0FBTTtRQUM3QixPQUFPLEVBQUUsSUFBSSxFQUFFLEdBQVUsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFBQSxDQUFDO0lBRUYsb0RBQW9EO0lBQ3BELDRFQUE0RTtJQUNyRSxRQUFRLENBQUMsR0FBUTtRQUN0QixPQUFPLEdBQVEsQ0FBQztJQUNsQixDQUFDO0lBRU0sa0JBQWtCLENBQUMsR0FBTSxFQUFFLEtBQWE7UUFDN0MsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFHRCxNQUFNLE9BQWdCLE9BQU87SUFJM0IsWUFBbUIsRUFBNkIsRUFBUyxPQUFlLEVBQzdELGFBQW1EO1FBRDNDLE9BQUUsR0FBRixFQUFFLENBQTJCO1FBQVMsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUM3RCxrQkFBYSxHQUFiLGFBQWEsQ0FBc0M7UUFDNUQsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUM7UUFDYixJQUFJLENBQUMsT0FBTyxHQUFHLE9BQU8sQ0FBQztRQUN2QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRWhDLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFRLEVBQUUsR0FBVyxFQUFFLEVBQUU7WUFDM0UsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUNkLE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLEVBQUUsQ0FBTSxDQUFDO0lBQ2QsQ0FBQztJQUlNLEtBQUssQ0FBQyxhQUFhO1FBQ3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQWtCLEVBQUUsR0FBVyxFQUFFLEVBQUU7WUFDdEcsTUFBTSxHQUFHLEdBQUcsTUFBTSxJQUFJLENBQUM7WUFDdkIsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDeEQsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLEVBQUUsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBTSxDQUFDO0lBQy9CLENBQUM7SUFFRCxLQUFLLENBQUMsY0FBYztRQUNsQixPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxFQUFFLEVBQUU7Z0JBQ3ZFLE9BQU8sTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO1lBQzdFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEIsQ0FBQztJQUVELDhEQUE4RDtJQUM5RCx1RUFBdUU7SUFDdkUsNkRBQTZEO0lBQ3RELEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBYztRQUNwQyxJQUFJLE9BQWtDLENBQUM7UUFFdkMsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxXQUFXLENBQUMsQ0FBQztRQUM5RCxJQUFJLGNBQXVCLENBQUM7UUFDNUIsSUFBSTtZQUNGLGNBQWMsR0FBRyxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztTQUMxRDtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFDRCxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ25CLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO1FBQ0QsT0FBTyxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekMsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUMzRSxLQUFLLE1BQU0sSUFBSSxJQUFJLFdBQVcsRUFBRTtZQUM5QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksUUFBUSxFQUFFO2dCQUNsQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxRQUFRLElBQUksTUFBTSxFQUFFO29CQUN0QixPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7aUJBQ2pGO2FBQ0Y7U0FDRjtRQUVELG9EQUFvRDtRQUNwRCwyQkFBMkI7UUFDM0IsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVELGlCQUFpQixDQUFDLFFBQW9DO1FBQ3BELEtBQUssSUFBSSxTQUFTLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFFakQsWUFBWSxDQUFhLFdBQVcsU0FBUyxNQUFNLEVBQUUsS0FBSyxJQUFJLEVBQUU7Z0JBQzlELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNuQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUU7Z0JBQy9CLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDO2dCQUM5RCxRQUFRLENBQUMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0MsQ0FBQyxDQUFDLENBQUM7WUFFSCxZQUFZLENBQWtCLFdBQVcsU0FBUyxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsUUFBUSxFQUF3QixFQUFFLEVBQUU7Z0JBQ2pHLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM3QyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUU7Z0JBQy9CLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUN6RCxRQUFRLENBQUMsQ0FBQyxTQUFTLEVBQUUsR0FBRyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDM0MsQ0FBQyxDQUFDLENBQUM7WUFFSCxZQUFZLENBQVUsV0FBVyxTQUFTLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxRQUFRLEVBQXdCLEVBQUUsRUFBRTtnQkFDaEcsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUMzQyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hGLE9BQU8sSUFBSSxDQUFDO1lBQ2QsQ0FBQyxDQUFDLENBQUM7U0FFSjtJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5cbmltcG9ydCB7IG1ha2VFbmRwb2ludCB9IGZyb20gJy4uLy4uL2FwaS9tYWluJztcblxuaW1wb3J0IHsgSW5kZXgsIEluZGV4YWJsZU9iamVjdCB9IGZyb20gJy4uL3F1ZXJ5JztcbmltcG9ydCB7IFdvcmtzcGFjZSB9IGZyb20gJy4uL3dvcmtzcGFjZSc7XG5cbmltcG9ydCB7IFlBTUxTdG9yYWdlIH0gZnJvbSAnLi95YW1sJztcblxuXG5jb25zdCBZQU1MX0VYVCA9ICcueWFtbCc7XG5cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0b3JlTWFuYWdlcjxPIGV4dGVuZHMgSW5kZXhhYmxlT2JqZWN0PiB7XG4gIHByb3RlY3RlZCBfaW5kZXg6IEluZGV4PE8+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyByb290RGlyOiBzdHJpbmcpIHt9XG5cbiAgcHVibGljIGFzeW5jIHN0b3JlSW5kZXgoc3RvcmFnZTogU3RvcmFnZTxhbnk+LCBuZXdJZHg6IEluZGV4PE8+IHwgdW5kZWZpbmVkKTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgY29uc3QgaWR4OiBJbmRleDxPPiA9IG5ld0lkeCB8fCBhd2FpdCB0aGlzLmdldEluZGV4KHN0b3JhZ2UpO1xuICAgIGNvbnN0IGl0ZW1zOiBPW10gPSBPYmplY3QudmFsdWVzKGlkeCk7XG5cbiAgICBmb3IgKGNvbnN0IG9iaiBvZiBpdGVtcykge1xuICAgICAgYXdhaXQgdGhpcy5zdG9yZShvYmosIHN0b3JhZ2UsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmRleCA9IGlkeDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRJbmRleChzdG9yYWdlOiBTdG9yYWdlPGFueT4pOiBQcm9taXNlPEluZGV4PE8+PiB7XG4gICAgaWYgKHRoaXMuX2luZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX2luZGV4ID0gYXdhaXQgdGhpcy5fbG9hZEluZGV4KHN0b3JhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5faW5kZXg7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgZmluZE9iamVjdHMoc3RvcmFnZTogU3RvcmFnZTxhbnk+LCBxdWVyeT86IHN0cmluZyk6IFByb21pc2U8SW5kZXg8Tz4+IHtcbiAgICBjb25zdCBpbmRleCA9IGF3YWl0IHRoaXMuZ2V0SW5kZXgoc3RvcmFnZSk7XG4gICAgaWYgKHF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZXN1bHRzOiBJbmRleDxPPiA9IHt9O1xuICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGluZGV4KSkge1xuICAgICAgICBjb25zdCBvYmogPSBpbmRleFtrZXldXG4gICAgICAgIGlmICh0aGlzLm9iamVjdE1hdGNoZXNRdWVyeShvYmosIHF1ZXJ5KSkge1xuICAgICAgICAgIHJlc3VsdHNba2V5XSA9IG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIF9sb2FkSW5kZXgoc3RvcmFnZTogU3RvcmFnZTxhbnk+KTogUHJvbWlzZTxJbmRleDxPPj4ge1xuICAgIGNvbnN0IHJvb3RQYXRoID0gdGhpcy5yb290RGlyO1xuICAgIGNvbnN0IGRpcnMgPSBhd2FpdCBzdG9yYWdlLmZzLnJlYWRkaXIocGF0aC5qb2luKHN0b3JhZ2Uud29ya0Rpciwgcm9vdFBhdGgpKTtcbiAgICB2YXIgaWR4OiBJbmRleDxPPiA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgaWYgKGRpciAhPSAnLkRTX1N0b3JlJykge1xuICAgICAgICBjb25zdCBvYmpEYXRhID0gYXdhaXQgc3RvcmFnZS5sb2FkT2JqZWN0KHBhdGguam9pbihyb290UGF0aCwgZGlyKSk7XG4gICAgICAgIGlmIChvYmpEYXRhKSB7XG4gICAgICAgICAgY29uc3Qgb2JqOiBPID0gdGhpcy5wb3N0TG9hZChvYmpEYXRhKTtcbiAgICAgICAgICBpZiAob2JqLmlkKSB7XG4gICAgICAgICAgICBpZHhbb2JqLmlkXSA9IG9iajtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIC8vIFRPRE86IFVzZSBgdG9Vc2VhYmxlT2JqZWN0KGRhdGE6IGFueSkgPT4gT2AgdG8gcG9zdC1wcm9jZXNzIGxvYWRlZCBkYXRhXG5cbiAgLy8gU3RvcmVzIG9iamVjdCBpbiBEQlxuICBwdWJsaWMgYXN5bmMgc3RvcmUob2JqOiBPLCBzdG9yYWdlOiBTdG9yYWdlPGFueT4sIHVwZGF0ZUluZGV4ID0gdHJ1ZSk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IG9iakRpciA9IHBhdGguam9pbih0aGlzLnJvb3REaXIsIGAke29iai5pZH1gKTtcbiAgICBjb25zdCBvYmpQYXRoID0gcGF0aC5qb2luKHN0b3JhZ2Uud29ya0Rpciwgb2JqRGlyKTtcbiAgICBjb25zdCBzdG9yZWFibGUgPSB0aGlzLnRvU3RvcmVhYmxlT2JqZWN0KG9iaik7XG5cbiAgICBhd2FpdCBzdG9yYWdlLmZzLmVuc3VyZURpcihvYmpQYXRoKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdG9yZWFibGUpKSB7XG4gICAgICBjb25zdCBkYXRhID0gc3RvcmVhYmxlW2tleV07XG4gICAgICBhd2FpdCBzdG9yYWdlLnlhbWwuc3RvcmUocGF0aC5qb2luKG9ialBhdGgsIGAke2tleX0ueWFtbGApLCBkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlSW5kZXggPT09IHRydWUpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlSW5kZXhlZEl0ZW0ob2JqLCBzdG9yYWdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyB1cGRhdGVJbmRleGVkSXRlbShvYmo6IE8sIHN0b3JhZ2U6IFN0b3JhZ2U8YW55Pikge1xuICAgIGF3YWl0IHRoaXMuZ2V0SW5kZXgoc3RvcmFnZSk7XG4gICAgKHRoaXMuX2luZGV4IGFzIEluZGV4PE8+KVtvYmouaWRdID0gb2JqO1xuICB9XG5cbiAgcHVibGljIHRvU3RvcmVhYmxlT2JqZWN0KG9iajogTyk6IGFueSB7XG4gICAgcmV0dXJuIHsgbWV0YTogb2JqIGFzIGFueSB9O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIG9iamVjdCBkYXRhIGludG8gdmFsaWQgb2JqZWN0LCBpZiBuZWVkZWRcbiAgLy8gKGluIGNhc2VzIHdoZW4gcGFydGlhbCBkYXRhIGlzIHN0b3JlZCBvciBtaWdyYXRpb24gdG9vayBwbGFjZSBwcmV2aW91c2x5KVxuICBwdWJsaWMgcG9zdExvYWQob2JqOiBhbnkpOiBPIHtcbiAgICByZXR1cm4gb2JqIGFzIE87XG4gIH1cblxuICBwdWJsaWMgb2JqZWN0TWF0Y2hlc1F1ZXJ5KG9iajogTywgcXVlcnk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTdG9yYWdlPFcgZXh0ZW5kcyBXb3Jrc3BhY2U+IHtcbiAgcHVibGljIHlhbWw6IFlBTUxTdG9yYWdlO1xuICBwdWJsaWMgd29ya3NwYWNlOiBXO1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBmczogdHlwZW9mIGltcG9ydCgnZnMtZXh0cmEnKSwgcHVibGljIHdvcmtEaXI6IHN0cmluZyxcbiAgICAgIHB1YmxpYyBzdG9yZU1hbmFnZXJzOiB7IFtrZXk6IHN0cmluZ106IFN0b3JlTWFuYWdlcjxhbnk+IH0pIHtcbiAgICB0aGlzLmZzID0gZnM7XG4gICAgdGhpcy53b3JrRGlyID0gd29ya0RpcjtcbiAgICB0aGlzLnlhbWwgPSBuZXcgWUFNTFN0b3JhZ2UoZnMpO1xuXG4gICAgdGhpcy53b3Jrc3BhY2UgPSBPYmplY3Qua2V5cyhzdG9yZU1hbmFnZXJzKS5yZWR1Y2UoKG9iajogYW55LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pIGFzIFc7XG4gIH1cblxuICBwdWJsaWMgYWJzdHJhY3QgYXN5bmMgZmluZE9iamVjdHMocXVlcnk/OiBzdHJpbmcpOiBQcm9taXNlPFc+XG5cbiAgcHVibGljIGFzeW5jIGxvYWRXb3Jrc3BhY2UoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy53b3Jrc3BhY2UgPSBhd2FpdCBPYmplY3Qua2V5cyh0aGlzLnN0b3JlTWFuYWdlcnMpLnJlZHVjZShhc3luYyAob2JqUDogUHJvbWlzZTxhbnk+LCBrZXk6IHN0cmluZykgPT4ge1xuICAgICAgY29uc3Qgb2JqID0gYXdhaXQgb2JqUDtcbiAgICAgIG9ialtrZXldID0gYXdhaXQgdGhpcy5zdG9yZU1hbmFnZXJzW2tleV0uZ2V0SW5kZXgodGhpcyk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sIFByb21pc2UucmVzb2x2ZSh7fSkpIGFzIFc7XG4gIH1cblxuICBhc3luYyBzdG9yZVdvcmtzcGFjZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLk9iamVjdC5rZXlzKHRoaXMuc3RvcmVNYW5hZ2VycykubWFwKGFzeW5jIChrZXkpID0+IHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnN0b3JlTWFuYWdlcnNba2V5XS5zdG9yZUluZGV4KHRoaXMsIHRoaXMud29ya3NwYWNlW2tleV0pO1xuICAgIH0pXSkudGhlbigoKSA9PiB0cnVlKTtcbiAgfVxuXG4gIC8vIExvYWRzIG9iamVjdCBkYXRhIGZyb20gZ2l2ZW4gZGlyZWN0b3J5LCByZWFkaW5nIFlBTUwgZmlsZXMuXG4gIC8vIG1ldGEueWFtbCBpcyB0cmVhdGVkIHNwZWNpYWxseSwgcG9wdWxhdGluZyB0b3AtbGV2ZWwgb2JqZWN0IHBheWxvYWQuXG4gIC8vIE90aGVyIFlBTUwgZmlsZXMgcG9wdWxhdGUgY29ycmVzcG9uZGluZyBvYmplY3QgcHJvcGVydGllcy5cbiAgcHVibGljIGFzeW5jIGxvYWRPYmplY3Qob2JqRGlyOiBzdHJpbmcpOiBQcm9taXNlPGFueSB8IHVuZGVmaW5lZD4ge1xuICAgIGxldCBvYmpEYXRhOiB7W3Byb3BOYW1lOiBzdHJpbmddOiBhbnl9O1xuXG4gICAgY29uc3QgbWV0YUZpbGUgPSBwYXRoLmpvaW4odGhpcy53b3JrRGlyLCBvYmpEaXIsICdtZXRhLnlhbWwnKTtcbiAgICBsZXQgbWV0YUZpbGVJc0ZpbGU6IGJvb2xlYW47XG4gICAgdHJ5IHtcbiAgICAgIG1ldGFGaWxlSXNGaWxlID0gKGF3YWl0IHRoaXMuZnMuc3RhdChtZXRhRmlsZSkpLmlzRmlsZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghbWV0YUZpbGVJc0ZpbGUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIG9iakRhdGEgPSBhd2FpdCB0aGlzLnlhbWwubG9hZChtZXRhRmlsZSk7XG5cbiAgICBjb25zdCBkaXJDb250ZW50cyA9IGF3YWl0IHRoaXMuZnMucmVhZGRpcihwYXRoLmpvaW4odGhpcy53b3JrRGlyLCBvYmpEaXIpKTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGlyQ29udGVudHMpIHtcbiAgICAgIGlmIChwYXRoLmV4dG5hbWUoaXRlbSkgPT0gWUFNTF9FWFQpIHtcbiAgICAgICAgY29uc3QgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lKGl0ZW0sIFlBTUxfRVhUKTtcbiAgICAgICAgaWYgKGJhc2VuYW1lICE9ICdtZXRhJykge1xuICAgICAgICAgIG9iakRhdGFbYmFzZW5hbWVdID0gYXdhaXQgdGhpcy55YW1sLmxvYWQocGF0aC5qb2luKHRoaXMud29ya0Rpciwgb2JqRGlyLCBpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBCbGluZGx5IGhvcGUgdGhhdCBkYXRhIHN0cnVjdHVyZSBsb2FkZWQgZnJvbSBZQU1MXG4gICAgLy8gaXMgdmFsaWQgZm9yIGdpdmVuIHR5cGUuXG4gICAgcmV0dXJuIG9iakRhdGE7XG4gIH1cblxuICBzZXRVcEFQSUVuZHBvaW50cyhub3RpZmllcjogKG5vdGlmeTogc3RyaW5nW10pID0+IHZvaWQpIHtcbiAgICBmb3IgKGxldCBpbmRleE5hbWUgb2YgT2JqZWN0LmtleXModGhpcy53b3Jrc3BhY2UpKSB7XG5cbiAgICAgIG1ha2VFbmRwb2ludDxJbmRleDxhbnk+Pihgc3RvcmFnZS0ke2luZGV4TmFtZX0tYWxsYCwgYXN5bmMgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy53b3Jrc3BhY2VbaW5kZXhOYW1lXTtcbiAgICAgIH0sIGFzeW5jICh7IG5ld0RhdGEsIG5vdGlmeSB9KSA9PiB7XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcmVNYW5hZ2Vyc1tpbmRleE5hbWVdLnN0b3JlSW5kZXgodGhpcywgbmV3RGF0YSk7XG4gICAgICAgIG5vdGlmaWVyKFtpbmRleE5hbWUsIC4uLihub3RpZnkgfHwgW10pXSk7XG4gICAgICB9KTtcblxuICAgICAgbWFrZUVuZHBvaW50PEluZGV4YWJsZU9iamVjdD4oYHN0b3JhZ2UtJHtpbmRleE5hbWV9YCwgYXN5bmMgKHsgb2JqZWN0SWQgfTogeyBvYmplY3RJZDogc3RyaW5nIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29ya3NwYWNlW2luZGV4TmFtZV1bb2JqZWN0SWRdO1xuICAgICAgfSwgYXN5bmMgKHsgbmV3RGF0YSwgbm90aWZ5IH0pID0+IHtcbiAgICAgICAgYXdhaXQgdGhpcy5zdG9yZU1hbmFnZXJzW2luZGV4TmFtZV0uc3RvcmUobmV3RGF0YSwgdGhpcyk7XG4gICAgICAgIG5vdGlmaWVyKFtpbmRleE5hbWUsIC4uLihub3RpZnkgfHwgW10pXSk7XG4gICAgICB9KTtcblxuICAgICAgbWFrZUVuZHBvaW50PGJvb2xlYW4+KGBzdG9yYWdlLSR7aW5kZXhOYW1lfS1kZWxldGVgLCBhc3luYyAoeyBvYmplY3RJZCB9OiB7IG9iamVjdElkOiBzdHJpbmcgfSkgPT4ge1xuICAgICAgICBkZWxldGUgdGhpcy53b3Jrc3BhY2VbaW5kZXhOYW1lXVtvYmplY3RJZF07XG4gICAgICAgIGF3YWl0IHRoaXMuc3RvcmVNYW5hZ2Vyc1tpbmRleE5hbWVdLnN0b3JlSW5kZXgodGhpcywgdGhpcy53b3Jrc3BhY2VbaW5kZXhOYW1lXSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICB9XG4gIH1cbn1cbiJdfQ==